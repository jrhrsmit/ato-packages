#!/usr/bin/env -S uv run --script
# /// script
# dependencies = ["pyyaml", "typer"]
# ///

"""
Generate the README.md with updated list of packages
"""

import yaml
from pathlib import Path
import logging
import typer

logger = logging.getLogger(__name__)

template = f"""
<!-- This document is autogenerated by {Path(__file__).name} -->
<!-- Do not edit this file manually!! -->

# ato-library

This is a monorepo for various ato and fabll packages.

## Available Packages

| Package | Modules | Description | Version |
|---------|---------|-------------|---------|
"""


def get_module_docstring(file_path, module_name):
    """Extract the docstring for a specific module from a file.
    Looks for the docstring after the module definition.
    """
    try:
        logger.debug(
            f"Attempting to read docstring for module {module_name} from: {file_path}"
        )
        with open(file_path, "r") as f:
            content = f.read()

            # Find the module definition
            module_def = f"module {module_name}"
            module_pos = content.find(module_def)

            if module_pos == -1:
                logger.debug(f"Module {module_name} not found")
                return "-"

            # Look for triple-quote docstrings after the module definition
            content_after_module = content[module_pos:]
            for quote in ['"""', "'''"]:
                start = content_after_module.find(quote)
                if start != -1:
                    # Find the closing quotes
                    end = content_after_module.find(quote, start + 3)
                    if end != -1:
                        docstring = content_after_module[start + 3 : end].strip()
                        logger.debug(f"Found docstring using {quote}")
                        return docstring

            logger.debug("No docstring found")
            return "-"
    except Exception as e:
        logger.error(f"Failed to read docstring from {file_path}: {e}")
        return "-"


def find_module_file(package_dir, module_entry):
    """Find the module file from the entry point."""
    if not module_entry or ":" not in module_entry:
        return None

    module_path, class_name = module_entry.split(":")
    # The module file is named after the package (e.g. debug-headers.ato, relays.ato)
    file_path = package_dir / f"{package_dir.name}.ato"
    logger.debug(f"Looking for module file: {file_path}")
    return file_path, class_name


def main(
    debug: bool = typer.Option(False, "-d", "--debug", help="Enable debug logging"),
):
    """Generate the README.md with updated list of packages."""
    # Set up logging based on debug flag
    logging.basicConfig(level=logging.DEBUG if debug else logging.INFO)

    packages_dir = Path("packages")
    table_rows = []

    # Find all directories with ato.yaml
    for package_dir in packages_dir.iterdir():
        if not package_dir.is_dir():
            continue

        ato_file = package_dir.joinpath("ato.yaml")
        if not ato_file.exists():
            continue

        logger.info(f"Processing package: {package_dir.name}")

        # Read and parse the ato.yaml file
        with open(ato_file, "r") as f:
            try:
                ato_config = yaml.safe_load(f)
                # Get package summary from package info
                package_info = ato_config.get("package", {})
                package_description = package_info.get("summary", "-")
                version = package_info.get("version", "-")

                # Extract build targets
                builds = ato_config.get("builds", {})
                num_modules = len(builds)
                module_text = f"{num_modules} module{'s' if num_modules != 1 else ''}"

                # Add package overview row first
                table_rows.append(
                    f"| {package_dir.name} | {module_text} | {package_description} | {version} |"
                )

                # Add a row for each module
                for build_name, build_info in builds.items():
                    # Get the module file from the entry point
                    module_info = find_module_file(package_dir, build_info.get("entry"))
                    if module_info is None:
                        build_description = "-"
                    else:
                        module_file, class_name = module_info
                        if module_file.exists():
                            build_description = get_module_docstring(
                                module_file, class_name
                            )
                        else:
                            build_description = "-"

                    # Convert newlines to HTML breaks for markdown table compatibility
                    build_description = (
                        build_description.replace("\n", "<br>")
                        if build_description
                        else "-"
                    )
                    table_rows.append(f"|  | {build_name} | {build_description} | |")

            except yaml.YAMLError:
                print(f"Error parsing {ato_file}")
                continue

    # Generate final markdown content
    content = template + "\n".join(table_rows) + "\n"

    # Write to README.md
    with open("README.md", "w") as f:
        f.write(content)

    logger.info("README.md updated successfully ðŸ’ª")


if __name__ == "__main__":
    typer.run(main)
